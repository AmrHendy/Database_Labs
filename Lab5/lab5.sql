DROP SCHEMA IF EXISTS LAB5;
CREATE SCHEMA LAB5;
USE LAB5;

CREATE TABLE IF NOT EXISTS DEPT(
	DNUMBER INT,
    DNAME VARCHAR(50) DEFAULT 'HENDY DEPT',
    FOUNDED DATE DEFAULT '2018-05-08',
    MGR_SSN INT,
    BUDGET INT DEFAULT 10,
	PRIMARY KEY(DNUMBER)
);

CREATE TABLE IF NOT EXISTS EMPLOYEE(
	SSN INT,
    ENAME VARCHAR(50) DEFAULT 'HENDY',
    BDATE DATE DEFAULT '2018-05-08',
    DNO INT,
    SALARY INT,
    PRIMARY KEY(SSN)
);

ALTER TABLE DEPT ADD CONSTRAINT FK_DEPT FOREIGN KEY(MGR_SSN) REFERENCES EMPLOYEE(SSN) ON UPDATE CASCADE ON DELETE CASCADE;
ALTER TABLE EMPLOYEE ADD CONSTRAINT FK_EMPLOYEE FOREIGN KEY(DNO) REFERENCES DEPT(DNUMBER) ON UPDATE CASCADE ON DELETE CASCADE;


-- stored function to get the number of employees of certain department

DROP FUNCTION IF EXISTS COUNT_EMP;
DELIMITER $$
CREATE FUNCTION COUNT_EMP(DNUMBER_ INT) RETURNS INT NOT DETERMINISTIC
BEGIN
	DECLARE EMPLOYEE_CNT INT;
	SELECT COUNT(*) INTO EMPLOYEE_CNT FROM EMPLOYEE AS E
    WHERE E.DNO = DNUMBER_;
    RETURN(EMPLOYEE_CNT);
END$$



-- stored procedure that ensures that Year(DEPT.Founded) >=1960 for
-- all departments; if a row violates this constraint then 
-- set its date to be â€™01-JAN-1960
DROP PROCEDURE IF EXISTS VALIDATE_YEAR$$
DELIMITER $$
CREATE PROCEDURE VALIDATE_YEAR()
BEGIN 
	UPDATE DEPT 
    SET FOUNDED = '1960-01-01'
    WHERE YEAR(FOUNDED) < 1960; 
END$$


-- a trigger to ensure that no department has more than 8 employees
-- Notice that we use FOR EACH ROW to check the matched rows only not all rows of the table.
DROP TRIGGER IF EXISTS BEFORE_INSERT_EMP$$
CREATE TRIGGER BEFORE_INSERT_EMP BEFORE INSERT ON EMPLOYEE FOR EACH ROW
BEGIN
	DECLARE DEPT_NUM INT;
    DECLARE TOTAL_EMP_CNT INT;
    SET DEPT_NUM = NEW.DNO;
    SELECT COUNT(*) INTO TOTAL_EMP_CNT FROM EMPLOYEE
    WHERE DNO = DEPT_NUM;
    IF TOTAL_EMP_CNT >= 8
    THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'INVALID INSERT AS MAX OF DEP IS 8 EMPLOYEES';
	END IF;
END$$



-- a trigger to implement "ON UPDATE CASCADE" for the foreign key EMPLOYEE.Dno
DROP TRIGGER IF EXISTS ON_UPDATE_CASCADE_IMPLEMENTATION$$
CREATE TRIGGER ON_UPDATE_CASCADE_IMPLEMENTATION AFTER UPDATE ON DEPT FOR EACH ROW
BEGIN
	-- USE <=> for safe checking for null then use ! outside
    -- As there is no !<=> operator in my sql
    -- Notice that we can do that trigger easily in oracle by using a certain column by:
    -- AFTER UPDATE OF DNUMBER ON DEPT
	IF !(NEW.DNUMBER <=> OLD.DNUMBER)
    THEN
		UPDATE EMPLOYEE
        SET DNO = NEW.DNUMBER
		WHERE DNO = OLD.DNUMBER;
	END IF;
END$$



-- a trigger to ensure that whenever an employee is given a raise in salary,
-- his department manager's salary must be increased to be at least as much.
DROP TRIGGER IF EXISTS AFTER_UPDATE_SALARY$$
CREATE TRIGGER AFTER_UPDATE_SALARY AFTER UPDATE ON EMPLOYEE FOR EACH ROW
BEGIN
	DECLARE MGR_SALARY INT;
    DECLARE MGR_ID INT;
    DECLARE DEPT_ID INT;
    IF !(NEW.SALARY <=> OLD.SALARY) AND NEW.SALARY > OLD.SALARY
    THEN
		SET DEPT_ID = OLD.DNO;
        SELECT MGR_SSN INTO MGR_ID FROM DEPT WHERE DNUMBER = DEPT_ID;
        SELECT SALARY INTO MGR_SALARY FROM EMPLOYEE WHERE SSN = MGR_ID;
		
        IF NEW.SSN != MGR_ID AND MGR_SALARY < NEW.SALARY THEN
			CALL UPDATE_SALARY_OUTSIDE(NEW.SALARY, MGR_ID);
        END IF;
	END IF;
END$$


DROP PROCEDURE IF EXISTS UPDATE_SALARY_OUTSIDE$$
DELIMITER $$
CREATE PROCEDURE UPDATE_SALARY_OUTSIDE(IN NEW_SALARY INT, IN MGR_ID INT)
BEGIN 
	UPDATE EMPLOYEE 
	SET SALARY = NEW_SALARY
	WHERE SSN = MGR_ID; 
END$$



DELIMITER ;

-- INSERT SOME DATA
INSERT INTO DEPT (DNUMBER, FOUNDED)
VALUES 	(1, '1970-05-01'),
		(2, '1950-11-01');
        
INSERT INTO EMPLOYEE (SSN, SALARY, DNO)
VALUES 	(1, 20, 1),
		(2, 21, 2),
		(3, 22, 2);
        
UPDATE DEPT SET MGR_SSN = 2 WHERE DNUMBER = 1;
UPDATE DEPT SET MGR_SSN = 3 WHERE DNUMBER = 2;

SELECT * FROM EMPLOYEE;
SELECT * FROM DEPT;


-- TESTING

-- Q1)
SELECT DNUMBER, COUNT_EMP(DNUMBER) FROM DEPT GROUP BY DNUMBER; 

-- Q2)
CALL VALIDATE_YEAR();
SELECT * FROM DEPT;

-- Q3)
INSERT INTO EMPLOYEE (SSN, SALARY, DNO)
VALUES 	(4, 40, 2),
		(5, 40, 2),
		(6, 40, 2),
        (7, 40, 2),
		(8, 40, 2),
		(9, 40, 2);

-- now department 2 has 8 employees so we will get error for new insert with dno = 2
INSERT INTO EMPLOYEE (SSN, SALARY, DNO)
VALUES 	(4, 40, 2);

-- remove the testing rows as they are redundant
DELETE FROM EMPLOYEE WHERE SSN >= 4;
SELECT * FROM EMPLOYEE;


-- Q4)
UPDATE DEPT SET DNUMBER = 200 WHERE DNUMBER = 1;
-- the dno with 1 will be 200, check that in EMPLOYEE table
SELECT * FROM EMPLOYEE;
-- return the prev state of DEPT table
UPDATE DEPT SET DNUMBER = 1 WHERE DNUMBER = 200;


-- Q5)
UPDATE EMPLOYEE SET SALARY = 200 WHERE SSN = 1;
SELECT * FROM EMPLOYEE;